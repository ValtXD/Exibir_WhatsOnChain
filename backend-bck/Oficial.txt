require('dotenv').config();
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const bsv = require('bsv');

const app = express();
const PORT = 3001;

app.use(express.json());
app.use(cors());

const PRIVATE_KEY_WIF = 'L1zhVFj1dJ2mS32EiysMYpMEmXE31tnTY7bwtyicGVTRwvyqVm1x';

try {
    const key = new bsv.PrivKey().fromWif(PRIVATE_KEY_WIF);
    console.log("‚úÖ Chave privada carregada com sucesso!");
} catch (error) {
    console.error("‚ùå Erro ao carregar a chave privada:", error.message);
}

// Fun√ß√£o para criar a transa√ß√£o OP_RETURN
const sendToWhatsOnChain = async (pacienteData) => {
    try {
        const key = new bsv.PrivKey().fromWif(PRIVATE_KEY_WIF);
        const address = bsv.Address.fromPrivKey(key);
        console.log("‚úÖ Endere√ßo da carteira:", address.toString());

        // Buscar UTXOs
        const { data: utxos } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/address/${address.toString()}/unspent`);
        if (utxos.length === 0) {
            throw new Error("‚ùå Sem saldo suficiente na carteira.");
        }

        const utxo = utxos[0];
        console.log("‚úÖ UTXO selecionado:", utxo);

        // Criar a transa√ß√£o
        const tx = new bsv.Tx();

        // Adicionar entrada (TxIn)
        tx.addTxIn(new bsv.TxIn({
            prevTxId: Buffer.from(utxo.tx_hash, 'hex'),
            outputIndex: utxo.tx_pos,
            script: new bsv.Script(), // Script de entrada vazio (ser√° preenchido na assinatura)
            output: new bsv.TxOut({
                script: bsv.Script.fromPubKeyHash(address.hashBuf), // Script de bloqueio do UTXO
                satoshis: utxo.value,
            }),
        }));

        // Adicionar sa√≠da OP_RETURN (TxOut)
        const opReturnData = Buffer.from(JSON.stringify(pacienteData), 'utf8');
        tx.addTxOut(new bsv.TxOut({
            script: bsv.Script.fromSafeData(opReturnData), // Script OP_RETURN
            satoshis: 0, // Valor zero para sa√≠da OP_RETURN
        }));

        // Assinar a transa√ß√£o
        tx.sign(key);

        console.log("‚úÖ Transa√ß√£o assinada!");

        // Enviar para WhatsOnChain
        const rawTx = tx.toHex();
        console.log("üì§ Enviando transa√ß√£o para WhatsOnChain...");

        const { data: txid } = await axios.post('https://api.whatsonchain.com/v1/bsv/main/tx/raw', { txhex: rawTx });

        console.log("‚úÖ Transa√ß√£o enviada com sucesso! TXID:", txid);
        return txid;
    } catch (error) {
        console.error('‚ùå Erro ao enviar transa√ß√£o:', error.message);
        throw new Error('Falha ao enviar para WhatsOnChain');
    }
};

// Rota para enviar transa√ß√£o
app.post('/api/enviar-transacao', async (req, res) => {
    try {
        const pacienteData = req.body;
        console.log("üì• Recebendo dados para transa√ß√£o:", pacienteData);

        const txid = await sendToWhatsOnChain(pacienteData);
        res.json({ success: true, txid });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
});
=======================Recente 05/02/25 ==================
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const bsv = require('bsv');

const app = express();
const PORT = 3001;

app.use(express.json());
app.use(cors());

const PRIVATE_KEY_WIF = 'L1zhVFj1dJ2mS32EiysMYpMEmXE31tnTY7bwtyicGVTRwvyqVm1x';

try {
    const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
    console.log("‚úÖ Chave privada carregada com sucesso!");
} catch (error) {
    console.error("‚ùå Erro ao carregar a chave privada:", error.message);
}

// Fun√ß√£o para criar e enviar a transa√ß√£o OP_RETURN
const sendToWhatsOnChain = async (pacienteData) => {
    try {
        const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
        const address = key.toAddress().toString();
        console.log("‚úÖ Endere√ßo da carteira:", address);

        // Buscar UTXOs
        const { data: utxos } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/address/${address}/unspent`);
        if (utxos.length === 0) {
            throw new Error("‚ùå Sem saldo suficiente na carteira.");
        }

        const utxo = utxos[0];
        console.log("‚úÖ UTXO selecionado:", utxo);

        // Obter scriptPubKey
        const { data: txDetails } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/tx/hash/${utxo.tx_hash}`);
        const scriptPubKey = txDetails.vout[utxo.tx_pos].scriptPubKey.hex;
        
        if (!scriptPubKey) throw new Error("Erro: scriptPubKey n√£o encontrado.");

        // Criar a transa√ß√£o
        const tx = new bsv.Transaction()
            .from([{
                txId: utxo.tx_hash,
                outputIndex: utxo.tx_pos,
                script: scriptPubKey,
                satoshis: utxo.value,
            }])
            .addOutput(new bsv.Transaction.Output({
                script: bsv.Script.buildDataOut(JSON.stringify(pacienteData)),
                satoshis: 0,
            }))
            .change(address) // Retorna o troco para o mesmo endere√ßo
            .sign(key);

        if (!tx.isFullySigned()) {
            throw new Error("‚ùå A transa√ß√£o n√£o foi assinada corretamente.");
        }

        // Serializar e enviar a transa√ß√£o
        const rawTx = tx.serialize(); // Alternativa ao toHex()
        console.log("üìú Raw Transaction:", rawTx);

        const { data: txid } = await axios.post(
            'https://api.whatsonchain.com/v1/bsv/main/tx/raw',
            { txhex: rawTx }
        );

        console.log("‚úÖ Transa√ß√£o enviada com sucesso! TXID:", txid);
        return txid;
    } catch (error) {
        console.error("‚ùå Erro ao enviar transa√ß√£o:", error.message);
        throw new Error("Falha ao enviar para WhatsOnChain");
    }
};

// Rota para envio de transa√ß√£o
app.post('/api/enviar-transacao', async (req, res) => {
    try {
        const pacienteData = req.body;
        console.log("üì• Recebendo dados para transa√ß√£o:", pacienteData);

        const txid = await sendToWhatsOnChain(pacienteData);
        res.json({ success: true, txid });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
});
===================================================================
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const bsv = require('bsv');

const app = express();
const PORT = 3001;

app.use(express.json());
app.use(cors());

const PRIVATE_KEY_WIF = 'L1zhVFj1dJ2mS32EiysMYpMEmXE31tnTY7bwtyicGVTRwvyqVm1x';

try {
    const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
    console.log("‚úÖ Chave privada carregada com sucesso!");
} catch (error) {
    console.error("‚ùå Erro ao carregar a chave privada:", error.message);
}

// Fun√ß√£o para criar e enviar a transa√ß√£o OP_RETURN
const sendToWhatsOnChain = async (pacienteData) => {
    try {
        const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
        const address = key.toAddress().toString();
        console.log("‚úÖ Endere√ßo da carteira:", address);

        // Buscar UTXOs
        const { data: utxos } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/address/${address}/unspent`);
        if (utxos.length === 0) {
            throw new Error("‚ùå Sem saldo suficiente na carteira.");
        }

        const utxo = utxos[0];
        console.log("‚úÖ UTXO selecionado:", utxo);

        // Obter a transa√ß√£o completa para o UTXO
        const { data: txData } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/tx/${utxo.tx_hash}`);
        const scriptPubKey = txData.outputs[utxo.tx_pos].script;

        if (!scriptPubKey) {
            throw new Error("‚ùå scriptPubKey n√£o encontrado na transa√ß√£o.");
        }

        // Criar o script OP_RETURN com os dados
        const opReturnData = bsv.Script.buildDataOut(
            Buffer.from(JSON.stringify(pacienteData), 'utf8')
        );

        // Criar a transa√ß√£o com OP_RETURN como a primeira sa√≠da
        const tx = new bsv.Transaction()
            .from([{
                txId: utxo.tx_hash,
                outputIndex: utxo.tx_pos,
                script: bsv.Script.fromHex(scriptPubKey), // Agora usamos o script extra√≠do da transa√ß√£o
                satoshis: utxo.value,
            }])
            .addOutput(new bsv.Transaction.Output({
                script: opReturnData,
                satoshis: 0, // OP_RETURN n√£o pode ter valor
            }))
            .feePerKb(1000) // Ajuste para taxa mais alta de 1000 satoshis por Kb
            .change(address) // Garantir que o troco seja enviado corretamente
            .sign(key);

        if (!tx.isFullySigned()) {
            throw new Error("‚ùå A transa√ß√£o n√£o foi assinada corretamente.");
        }

        // Serializar e enviar a transa√ß√£o
        const rawTx = tx.serialize();
        console.log("üìú Raw Transaction:", rawTx);

        const { data: txid } = await axios.post(
            'https://api.whatsonchain.com/v1/bsv/main/tx/raw',
            { txhex: rawTx }
        );

        console.log("‚úÖ Transa√ß√£o enviada com sucesso! TXID:", txid);
        return txid;
    } catch (error) {
        console.error("‚ùå Erro ao enviar transa√ß√£o:", error.message);
        throw new Error("Falha ao enviar para WhatsOnChain");
    }
};

// Rota para envio de transa√ß√£o
app.post('/api/enviar-transacao', async (req, res) => {
    try {
        const pacienteData = req.body;
        console.log("üì• Recebendo dados para transa√ß√£o:", pacienteData);

        const txid = await sendToWhatsOnChain(pacienteData);
        res.json({ success: true, txid });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
});
===============================================================
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const bsv = require('bsv');

const app = express();
const PORT = 3001;

app.use(express.json());
app.use(cors());

const PRIVATE_KEY_WIF = 'L1zhVFj1dJ2mS32EiysMYpMEmXE31tnTY7bwtyicGVTRwvyqVm1x';

try {
    const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
    console.log("‚úÖ Chave privada carregada com sucesso!");
} catch (error) {
    console.error("‚ùå Erro ao carregar a chave privada:", error.message);
}

// Fun√ß√£o para criar e enviar a transa√ß√£o OP_RETURN
const sendToWhatsOnChain = async (pacienteData) => {
    try {
        const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
        const address = key.toAddress().toString();
        console.log("‚úÖ Endere√ßo da carteira:", address);

        // Buscar UTXOs
        const { data: utxos } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/address/${address}/unspent`);
        if (utxos.length === 0) {
            throw new Error("‚ùå Sem saldo suficiente na carteira.");
        }

        const utxo = utxos[0];
        console.log("‚úÖ UTXO selecionado:", utxo);

        // Obter a transa√ß√£o completa para o UTXO
        const { data: txData } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/tx/${utxo.tx_hash}`);
        console.log("üìú Dados da transa√ß√£o:", txData);  // Logando os dados da transa√ß√£o para inspe√ß√£o

        // Verificar se a transa√ß√£o tem sa√≠das suficientes
        if (!txData.outputs || txData.outputs.length <= utxo.tx_pos) {
            throw new Error("‚ùå Sa√≠da (output) da transa√ß√£o n√£o encontrada ou √≠ndice incorreto.");
        }

        const scriptPubKey = txData.outputs[utxo.tx_pos].script;
        if (!scriptPubKey) {
            throw new Error("‚ùå scriptPubKey n√£o encontrado na transa√ß√£o.");
        }

        // Criar o script OP_RETURN com os dados
        const opReturnData = bsv.Script.buildDataOut(
            Buffer.from(JSON.stringify(pacienteData), 'utf8')
        );

        // Criar a transa√ß√£o com OP_RETURN como a primeira sa√≠da
        const tx = new bsv.Transaction()
            .from([{
                txId: utxo.tx_hash,
                outputIndex: utxo.tx_pos,
                script: bsv.Script.fromHex(scriptPubKey), // Agora usamos o script extra√≠do da transa√ß√£o
                satoshis: utxo.value,
            }])
            .addOutput(new bsv.Transaction.Output({
                script: opReturnData,
                satoshis: 0, // OP_RETURN n√£o pode ter valor
            }))
            .feePerKb(1000) // Ajuste para taxa mais alta de 1000 satoshis por Kb
            .change(address) // Garantir que o troco seja enviado corretamente
            .sign(key);

        if (!tx.isFullySigned()) {
            throw new Error("‚ùå A transa√ß√£o n√£o foi assinada corretamente.");
        }

        // Serializar e enviar a transa√ß√£o
        const rawTx = tx.serialize();
        console.log("üìú Raw Transaction:", rawTx);

        const { data: txid } = await axios.post(
            'https://api.whatsonchain.com/v1/bsv/main/tx/raw',
            { txhex: rawTx }
        );

        console.log("‚úÖ Transa√ß√£o enviada com sucesso! TXID:", txid);
        return txid;
    } catch (error) {
        console.error("‚ùå Erro ao enviar transa√ß√£o:", error.message);
        throw new Error("Falha ao enviar para WhatsOnChain");
    }
};

// Rota para envio de transa√ß√£o
app.post('/api/enviar-transacao', async (req, res) => {
    try {
        const pacienteData = req.body;
        console.log("üì• Recebendo dados para transa√ß√£o:", pacienteData);

        const txid = await sendToWhatsOnChain(pacienteData);
        res.json({ success: true, txid });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
});
===========================================================
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const bsv = require('bsv');

const app = express();
const PORT = 3001;

app.use(express.json());
app.use(cors());

const PRIVATE_KEY_WIF = 'L1zhVFj1dJ2mS32EiysMYpMEmXE31tnTY7bwtyicGVTRwvyqVm1x';

try {
    const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
    console.log("‚úÖ Chave privada carregada com sucesso!");
} catch (error) {
    console.error("‚ùå Erro ao carregar a chave privada:", error.message);
}

// Fun√ß√£o para criar e enviar a transa√ß√£o OP_RETURN
const sendToWhatsOnChain = async (pacienteData) => {
    try {
        const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
        const address = key.toAddress().toString();
        console.log("‚úÖ Endere√ßo da carteira:", address);

        // Buscar UTXOs
        const { data: utxos } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/address/${address}/unspent`);
        if (utxos.length === 0) {
            throw new Error("‚ùå Sem saldo suficiente na carteira.");
        }

        const utxo = utxos[0];
        console.log("‚úÖ UTXO selecionado:", utxo);

        // Obter a transa√ß√£o completa para o UTXO
        const { data: txData } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/tx/${utxo.tx_hash}`);

        if (!txData.vout || txData.vout.length <= utxo.tx_pos) {
            throw new Error("‚ùå Sa√≠da (output) da transa√ß√£o n√£o encontrada ou √≠ndice incorreto.");
        }

        const scriptPubKey = txData.vout[utxo.tx_pos].scriptPubKey;
        if (!scriptPubKey || !scriptPubKey.hex) {
            throw new Error("‚ùå scriptPubKey n√£o encontrado ou inv√°lido.");
        }

        console.log("üîë scriptPubKey da sa√≠da selecionada:", scriptPubKey.hex);

        // Criar um JSON menor para testar OP_RETURN
        const opReturnData = bsv.Script.buildDataOut(
            Buffer.from(JSON.stringify({ nome: pacienteData.nome, cpf: pacienteData.cpf }), 'utf8')
        );

        // Criar a transa√ß√£o
        const tx = new bsv.Transaction()
            .from([{
                txId: utxo.tx_hash,
                outputIndex: utxo.tx_pos,
                script: bsv.Script.fromHex(scriptPubKey.hex),
                satoshis: utxo.value,
            }])
            .addOutput(new bsv.Transaction.Output({
                script: opReturnData,
                satoshis: 0, // OP_RETURN n√£o pode ter valor
            }))
            .feePerKb(500) // Reduzi a taxa para evitar erro 400
            .change(address) // Troco para a carteira original
            .sign(key);

        if (!tx.isFullySigned()) {
            throw new Error("‚ùå A transa√ß√£o n√£o foi assinada corretamente.");
        }

        // Validar taxa e troco
        console.log("üìù Taxa estimada:", tx.getFee(), "satoshis");
        console.log("üí∞ Troco:", tx.getChangeOutput() ? tx.getChangeOutput().satoshis : 0, "satoshis");

        // Serializar e enviar a transa√ß√£o
        const rawTx = tx.serialize();
        console.log("üìú Raw Transaction:", rawTx);

        const { data: txid } = await axios.post(
            'https://api.whatsonchain.com/v1/bsv/main/tx/raw',
            { txhex: rawTx }
        );

        console.log("‚úÖ Transa√ß√£o enviada com sucesso! TXID:", txid);
        return txid;
    } catch (error) {
        console.error("‚ùå Erro ao enviar transa√ß√£o:", error.message);
        throw new Error("Falha ao enviar para WhatsOnChain");
    }
};

// Rota para envio de transa√ß√£o
app.post('/api/enviar-transacao', async (req, res) => {
    try {
        const pacienteData = req.body;
        console.log("üì• Recebendo dados para transa√ß√£o:", pacienteData);

        const txid = await sendToWhatsOnChain(pacienteData);
        res.json({ success: true, txid });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
});
==========================================================06/02/25
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const bsv = require('bsv');

const app = express();
const PORT = 3001;

app.use(express.json());
app.use(cors());

const PRIVATE_KEY_WIF = 'L1zhVFj1dJ2mS32EiysMYpMEmXE31tnTY7bwtyicGVTRwvyqVm1x';

try {
    const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
    console.log("‚úÖ Chave privada carregada com sucesso!");
} catch (error) {
    console.error("‚ùå Erro ao carregar a chave privada:", error.message);
}

// Fun√ß√£o para criar e enviar a transa√ß√£o OP_RETURN
const sendToWhatsOnChain = async (pacienteData) => {
    try {
        const key = bsv.PrivateKey.fromWIF(PRIVATE_KEY_WIF);
        const address = key.toAddress().toString();
        console.log("‚úÖ Endere√ßo da carteira:", address);

        // Buscar UTXOs
        const { data: utxos } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/address/${address}/unspent`);
        if (utxos.length === 0) {
            throw new Error("‚ùå Sem saldo suficiente na carteira.");
        }

        const utxo = utxos[0];
        console.log("‚úÖ UTXO selecionado:", utxo);

        // Obter a transa√ß√£o completa para o UTXO
        const { data: txData } = await axios.get(`https://api.whatsonchain.com/v1/bsv/main/tx/${utxo.tx_hash}`);

        if (!txData.vout || txData.vout.length <= utxo.tx_pos) {
            throw new Error("‚ùå Sa√≠da (output) da transa√ß√£o n√£o encontrada ou √≠ndice incorreto.");
        }

        const scriptPubKey = txData.vout[utxo.tx_pos].scriptPubKey;
        if (!scriptPubKey || !scriptPubKey.hex) {
            throw new Error("‚ùå scriptPubKey n√£o encontrado ou inv√°lido.");
        }

        console.log("üîë scriptPubKey da sa√≠da selecionada:", scriptPubKey.hex);

        // Criar um JSON menor para testar OP_RETURN
        const opReturnData = bsv.Script.buildDataOut(
            Buffer.from(JSON.stringify({ nome: pacienteData.nome, cpf: pacienteData.cpf }), 'utf8')
        );

        // Criar a transa√ß√£o
        const tx = new bsv.Transaction()
            .from([{
                txId: utxo.tx_hash,
                outputIndex: utxo.tx_pos,
                script: bsv.Script.fromHex(scriptPubKey.hex),
                satoshis: utxo.value,
            }])
            .addOutput(new bsv.Transaction.Output({
                script: opReturnData,
                satoshis: 0, // OP_RETURN n√£o pode ter valor
            }))
            .feePerKb(500) // Reduzi a taxa para evitar erro 400
            .change(address) // Troco para a carteira original
            .sign(key);

        if (!tx.isFullySigned()) {
            throw new Error("‚ùå A transa√ß√£o n√£o foi assinada corretamente.");
        }

        // Validar taxa e troco
        console.log("üìù Taxa estimada:", tx.getFee(), "satoshis");
        console.log("üí∞ Troco:", tx.getChangeOutput() ? tx.getChangeOutput().satoshis : 0, "satoshis");

        // Serializar e enviar a transa√ß√£o
        const rawTx = tx.serialize();
        console.log("üìú Raw Transaction:", rawTx);

        const { data: txid } = await axios.post(
            'https://api.whatsonchain.com/v1/bsv/main/tx/raw',
            { txhex: rawTx }
        );

        console.log("‚úÖ Transa√ß√£o enviada com sucesso! TXID:", txid);
        return txid;
    } catch (error) {
        console.error("‚ùå Erro ao enviar transa√ß√£o:", error.message);
        throw new Error("Falha ao enviar para WhatsOnChain");
    }
};

// Rota para envio de transa√ß√£o
app.post('/api/enviar-transacao', async (req, res) => {
    try {
        const pacienteData = req.body;
        console.log("üì• Recebendo dados para transa√ß√£o:", pacienteData);

        const txid = await sendToWhatsOnChain(pacienteData);
        res.json({ success: true, txid });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
});
